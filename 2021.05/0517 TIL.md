# 0517 TIL

## Server & Client

:rabbit: Server

- 클라이언트에게 정보, 서비스를 제공하는 컴퓨터 시스템
- 정보 & 시스템
  - Django를 통해 응답한 template
  - DRF를 통해 응답한 JSON

:rabbit: Client

- 서버에게 그 서버가 맞는 (서버가 제공하는) <u>서비스를 요청</u>하고
- 서비스 요청을 위해 필요한 인자를 <u>서버가 원하는 방식에 맞게 제공</u>하며
- 서버로부터 반환되는 응답을 <u>사용자에게 적절한 방식으로 표현</u>하는 기능을 가진 시스템

:rabbit: 정리

- Server는 정보 제공
  - DB와 통신하며 데미어틀 CRUD
  - 요청을 보낸 Client에게 이러한 정보를 응답
- Client는 정보 요청 & 표현
  - Server에게 정보(데이터) 요청
  - 응답 받은 정보를 잘 가공하여 화면에 보여줌

## CORS

:rabbit: Same-origin policy (SOP)

- 동일 출처 정책
- 특정 출처(origin)에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용 하는 것을 제한하는 보안 방식
- 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄임
- 정의
  - 두 URL의 Protocol, Port, Host가 모두 같아야 동일한 출처라고 할 수 있음

:rabbit: Cross-Origin Resource Sharing (CORS)

- 교차 출처 리소스 (자원) 공유
- <u>추가 HTTP header를 사용</u>하여, 특정 출처에서 실행중인 웹 애플리케이션이 <u>다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제</u>
- 리소스가 자신의 출처(Domain, Protocol, Port)와 다를 때 교차 출처 HTTP 요청을 실행
- 보안 상의 이유로 브라우저는 교차 출처 HTTP 요청을 제한 (SOP)
  - 예를 들어 XMLHttpReaquest는 SOP를 따름
- 다른 출처의 리소스를 불러오려면 그 출처에서 <u>올바른 CORS header를 포함한 응답을 반환해야함</u>

- 다른 출처(origin)에서 온 리소스를 공유하는 것에 대한 정책
- <--> SOP

:rabbit: 교차 출처 접근 허용하기

- CORS를 사용해 교차 출처 접근 허용
- CORS는 HTTP의 일부로, 어떤 호스트에서 자신의 컨텐츠를 불러갈 수 있는지 <u>서버에 지정할 수 있는 방법</u>

:rabbit: Why CORS?

1. 브라우저 & 웹 애플리케이션 보호
   - 악의적인 사이트의 데이터를 가져오지 않도록 사전 차단
   - 응답으로 ㅂ다는 자원에 대한 최소한의 검증
   - 서버는 정상적으로 응답하지만 브라우저에서 차단
2. Server의 자원 관리
   - 누가 해당 리소스에 접근 할 수 있는지 관리 가능

:rabbit: How CORS?

- CORS 표준에 의해 추가된 HTTP Header를 통해 이를 통제
- CORS HTTP 응답 헤더 예시
  - **Access-Control-Allow-Origin** / Access-Control-Allow-Credentials / Access-Control-Allow-Headers / Access-Control-Allow-Methods

:rabbit: Access-Control-Allow-Origin 응답 헤더

- 이 응답이 주어진 출처(origin)으로 부터 요청 코드와 공유될 수 있는지를 나타냄
- 예시
  - Access-Control-Allow-Origin: *
  - 브라우저 리소스에 접근하는 임의의 origin으로 부터 요청을 허용한다고 알리는 응답에 포함
  - '*'는 모든 도메인에서 접근할 수 있음을 의미
  - '*' 외에 특정 origin 하나를 명시할 수 있음

:rabbit: CORS 시나리오 예시

사진 참고

- https://localhost:8000의 웹 컨텐츠가 https://www.naver.com 도메인의 컨텐츠를 호출하기를 원함
- 요청 헤더의 Origin을 보면 localhost:8000으로부터 요청이 왔다는 것을 알 수 있음
- 서버는 이에 대한 응답으로 Access-Control-Allow-Origin 헤더를 다시 전송
- 만약 서버의 리소스 소유자가 오직 localhost:8000의 요청만 리소스에 대한 접근을 허용하려는 경우 '*'가 아닌 `Access-Control-Allow-Origin: localhost:8000`을 전송해야함

1. Vue.js에서 A 서버로 요청
2. A 서버는 Access-Control-Allow-Origin에 특정한 origin을 포함시켜 응답
   - 서버는 CORS Policy와 직접적인 연관이 없고 그저 요청에 응답함
3. 브라우저는 응답에 Access-Control-Allow-Origin를 확인 후 허용 여부를 결정
4. 프레임워크 별로 이를 지원하려는 라이브러리가 존재
   - django는 django-cors-headers 라이브러리를 통해 응답 헤더 및 추가 설정 가능

---

03_vue_with_django 코드 

코드 열어서 python -m venv venv --> source venv/Scripts/activate

pip install -r requirements.txt

python manage.py migrate

지금은 settings.py에 주석처리 된 게 많은데 이따 필요할 때 주석 풀 것

views.py로 들어가자.

postman 켜고, post로 'http://127/0/0/1:8000/todos/'로 보낸다.

body에 키는 title, value는 할일 1 이렇게 하면 

```
{
	"id": 1,
	"title": "할일 1",
	"completed": false,
}
```

이렇게 보내진다.

4개 정도 보낸 후, db_sqlite3 확인하면 데이터 4개 들어가있음

---

수정, 삭제도 문제가 없는지 확인

이건 todo.pk가 필요하다.

PUT --> 'http://127/0/0/1:8000/todos/1'로 보내고, body로 수정하면 됨

DELETE 'http://127/0/0/1:8000/todos/1'도 삭제 잘 됨

지금 장고는 문제 없다.

---

터미널 하나 더 생성하기.

네모 두 개 붙어있는 스플릿 터미널 누르자

왼:client로 들어온 상태 --> `npm install`

오:장고 서버 켜기 source venv/Scripts/activate

왼:npm run serve

양쪽 다 서버가 localhost는 같은 8080과 8000으로 다르다.

TodoList.vue

버튼을 누르면 getTodos 메서드로 요청을 보내는데, axios로 장고로  get으로 url을 보낸다.

근데 이러면 장고에서 get으로는 전체 리스트를 보여주고, post로는 추가되는 것이다.

data에는 todos: null로 설정

이대로 서버를 켜서 console을 확인해보면 CORS policy에 의해 막혔다고 뜬다.

서버는 응답을 해줬는데 브라우저 상에서 막힌 것이다.

장고로 돌아가보자.

장고에 cors header를 붙여주는 django-cors-headers가 있다. 구글에 검색하면 됨.

보니까 우리는 이미 깔려있다. settings.py에서 INSTALLED_APPS에서 'corsheaders' 주석 풀기

MiDDELEWARE -> 2번째에 있는 거 주석 풀기. 이거는 최대한 위에 있음 좋다고 한다.

오늘은 수업을 위해 settings.py에서 중간에 적혀있을 것. 1과 2가..

2. 모든 origin 허용으로 하자.

---

이제 추가 완료

TodoList.vue

get todos 버튼 주석처리하고

67번째 쯤에 created 이하 주석 해제

이러면 버튼이 없어도 create가 호출된다.

---

createtodo.vue

이 부분은 교수님 코드랑 비교하기...